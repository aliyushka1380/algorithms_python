"""
Задание 3.

Для этой задачи:
1) придумайте 1-3 решения (желательно хотя бы два)
2) оцените сложность каждого решения в нотации О-большое
3) сделайте вывод, какое решение эффективнее и почему

Примечание:
Без выполнения пунктов 2 и 3 задание считается нерешенным. Пункты 2 и 3 можно выполнить
через строки документации в самом коде.
Если у вас возникают сложности, постарайтесь подумать как можно решить задачу,
а не писать "мы это не проходили)".
Алгоритмизатор должен развивать мышление, а это прежде всего практика.
А без столкновения со сложностями его не развить.


Сама задача:
Имеется хранилище с информацией о компаниях: название и годовая прибыль.
Для реализации хранилища можно применить любой подход,
который вы придумаете, например, реализовать словарь.
Реализуйте поиск трех компаний с наибольшей годовой прибылью.
Выведите результат.
"""
firm_profit = {'Первый':1000, 'Второй':5000, 'Третий': 2000, 'Четвертый': 500, 'Пятый': 100, 'Шестой': 3000}

# Вариант 1: сложность NlogN - Линейно-логарифмическая
import operator

new_firm_profit = dict(sorted(iter(firm_profit.items()), key=operator.itemgetter(1), reverse=True)[:3])   # O(NlogN)
print(new_firm_profit)

# Вариант 2: сложность NlogN - Линейно-логарифмическая
from collections import Counter

new_firm_profit = dict(Counter(firm_profit).most_common(3)) #O(n log n)
print(new_firm_profit)

# Вариант 3: сложность NlogN - Линейно-логарифмическая
d = {'Первый':1000, 'Второй':5000, 'Третий': 2000, 'Четвертый': 500, 'Пятый': 100, 'Шестой': 3000} # O(1)
list_d = list(d.items()) # O(1)
list_d.sort(key=lambda i: i[1], reverse=True) # O(NlogN)
for i in list_d[:3]: # O(N)
    print(i[0], ':', i[1]) # O(1)

"""
Во всех решениях NlogN. Думаю, второй вариант предпочтительнее - меньше операций.
"""
